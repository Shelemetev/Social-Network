{"version":3,"file":"static/js/169.32c9805f.chunk.js","mappings":"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","sources":["webpack://my-app/./src/components/User/users.module.css?e3d7","webpack://my-app/./src/comon/Paginators/Paginator.module.css?e9b8","comon/Paginators/Paginator.jsx","webpack://my-app/./src/components/User/User/User.module.css?edd6","components/User/User/User.jsx","components/User/Users.jsx","../node_modules/reselect/src/utils.ts","../node_modules/reselect/src/autotrackMemoize/proxy.ts","../node_modules/reselect/src/weakMapMemoize.ts","../node_modules/reselect/src/createSelectorCreator.ts","../node_modules/reselect/src/createStructuredSelector.ts","redux/redux-select/user-reselect.js","components/User/UsersContainer.jsx","hocs/RedirectHoc.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"users\":\"users_users__-4SkD\",\"users__inner\":\"users_users__inner__kiFB+\"};","// extracted by mini-css-extract-plugin\nexport default {\"button__box\":\"Paginator_button__box__d6GR1\",\"pagination__button\":\"Paginator_pagination__button__wTLU2\",\"pagination__button--active\":\"Paginator_pagination__button--active__labOg\"};","import React from \"react\"\r\nimport s from './Paginator.module.css'\r\n\r\nconst Paginator = React.memo((props) => {\r\n    let pages = []\r\n\r\n    for (let index = 1; index <= props.numberPage; index++) {\r\n        pages.push(index)\r\n    }\r\n    return (\r\n        <div className={s.button__box}>\r\n            {\r\n                pages.map(item => {\r\n                    return <button key={item} className={`${s.pagination__button} ${props.countPage === item && s['pagination__button--active']}`} onClick={(e) => {\r\n                        props.onPageChange(item)\r\n                    }}>{item}</button>\r\n                })\r\n            }\r\n        </div>\r\n    )\r\n})\r\n\r\nexport default Paginator","// extracted by mini-css-extract-plugin\nexport default {\"user\":\"User_user__2zzmQ\",\"user__img\":\"User_user__img__qG1QU\",\"user__btn\":\"User_user__btn__Zz0Pz\"};","import React from \"react\";\r\nimport { NavLink } from 'react-router-dom';\r\nimport s from './User.module.css'\r\n\r\nconst User = React.memo((props) => {\r\n    return (\r\n        <div className={s.user} key={props.id}>\r\n            <NavLink to={\"/profile/\" + props.id} onClick={() => { props.profileUpdate(props.id); props.startLoader() }} >\r\n                <img className={s.user__img} src={\r\n                    (props.photos.small != null ? props.photos.small : (props.photos.large != null ? props.photos.large : 'https://avatars.mds.yandex.net/i?id=21dcf193f9d4ea021c56529f8af1956a46b3ed81-10844270-images-thumbs&n=13'))\r\n                } alt=\"\" />\r\n            </NavLink>\r\n            {props.followed ? <button disabled={props.toggleFollowingProgress} onClick={() => {\r\n                props.startLoader()\r\n                props.deleteFriend(props.id)\r\n            }} className={s.user__btn}>Delete friend</button> : <button disabled={props.toggleFollowingProgress} onClick={() => {\r\n                props.startLoader()\r\n                props.addFriend(props.id)\r\n            }} className={s.user__btn}>Add friend</button>}\r\n            <div className={s.user__list}>\r\n                <p className={s['user__list-item']}>Name:{props.name}</p>\r\n                <p className={s['user__list-item']}>Status:{props.status}</p>\r\n            </div>\r\n        </div>\r\n    )\r\n})\r\n\r\nexport default User","import React from 'react';\r\nimport s from './users.module.css'\r\nimport Paginator from './../../comon/Paginators/Paginator';\r\nimport User from './User/User';\r\n\r\nlet Users = React.memo ((props) => {\r\n    \r\n\r\n    return (\r\n        <div className={s.users}>\r\n            <div className={s.users__inner}>\r\n                <Paginator countPage={props.countPage} numberPage={props.numberPage} onPageChange={props.onPageChange} /> \r\n                {\r\n                    props.users.map((item) => {\r\n\r\n\r\n                        let addFriend = (id) => {\r\n                            props.toggleFollowing(true)\r\n                            props.postUsersThunk(id)\r\n                            props.followFriend(id,true)\r\n                        }\r\n\r\n                        let deleteFriend = (id) => {\r\n                            props.toggleFollowing(false)\r\n                            props.deleteUsersThunk(id)\r\n                            props.followFriend(id,false)\r\n                        }\r\n\r\n                        let profileUpdate = (id) => {\r\n                            props.profileUpdateMetod(id)\r\n                        }\r\n                        return (\r\n                            <User id={item.id} name={item.name} status={item.status} addFriend={addFriend} deleteFriend={deleteFriend} photos={item.photos} profileUpdate={profileUpdate} startLoader={props.startLoader} followed={item.followed} />\r\n                        )\r\n                    })\r\n                }\r\n            </div>\r\n        </div>\r\n    )\r\n})\r\n\r\nexport default Users\r\n\r\n","import { runIdentityFunctionCheck } from './devModeChecks/identityFunctionCheck'\nimport { runInputStabilityCheck } from './devModeChecks/inputStabilityCheck'\nimport { globalDevModeChecks } from './devModeChecks/setGlobalDevModeChecks'\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\nimport type {\n  DevModeChecks,\n  Selector,\n  SelectorArray,\n  DevModeChecksExecutionInfo\n} from './types'\n\nexport const NOT_FOUND = 'NOT_FOUND'\nexport type NOT_FOUND_TYPE = typeof NOT_FOUND\n\n/**\n * Assert that the provided value is a function. If the assertion fails,\n * a `TypeError` is thrown with an optional custom error message.\n *\n * @param func - The value to be checked.\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\n * @throws A `TypeError` if the assertion fails.\n */\nexport function assertIsFunction<FunctionType extends Function>(\n  func: unknown,\n  errorMessage = `expected a function, instead received ${typeof func}`\n): asserts func is FunctionType {\n  if (typeof func !== 'function') {\n    throw new TypeError(errorMessage)\n  }\n}\n\n/**\n * Assert that the provided value is an object. If the assertion fails,\n * a `TypeError` is thrown with an optional custom error message.\n *\n * @param object - The value to be checked.\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\n * @throws A `TypeError` if the assertion fails.\n */\nexport function assertIsObject<ObjectType extends Record<string, unknown>>(\n  object: unknown,\n  errorMessage = `expected an object, instead received ${typeof object}`\n): asserts object is ObjectType {\n  if (typeof object !== 'object') {\n    throw new TypeError(errorMessage)\n  }\n}\n\n/**\n * Assert that the provided array is an array of functions. If the assertion fails,\n * a `TypeError` is thrown with an optional custom error message.\n *\n * @param array - The array to be checked.\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\n * @throws A `TypeError` if the assertion fails.\n */\nexport function assertIsArrayOfFunctions<FunctionType extends Function>(\n  array: unknown[],\n  errorMessage = `expected all items to be functions, instead received the following types: `\n): asserts array is FunctionType[] {\n  if (\n    !array.every((item): item is FunctionType => typeof item === 'function')\n  ) {\n    const itemTypes = array\n      .map(item =>\n        typeof item === 'function'\n          ? `function ${item.name || 'unnamed'}()`\n          : typeof item\n      )\n      .join(', ')\n    throw new TypeError(`${errorMessage}[${itemTypes}]`)\n  }\n}\n\n/**\n * Ensure that the input is an array. If it's already an array, it's returned as is.\n * If it's not an array, it will be wrapped in a new array.\n *\n * @param item - The item to be checked.\n * @returns An array containing the input item. If the input is already an array, it's returned without modification.\n */\nexport const ensureIsArray = (item: unknown) => {\n  return Array.isArray(item) ? item : [item]\n}\n\n/**\n * Extracts the \"dependencies\" / \"input selectors\" from the arguments of `createSelector`.\n *\n * @param createSelectorArgs - Arguments passed to `createSelector` as an array.\n * @returns An array of \"input selectors\" / \"dependencies\".\n * @throws A `TypeError` if any of the input selectors is not function.\n */\nexport function getDependencies(createSelectorArgs: unknown[]) {\n  const dependencies = Array.isArray(createSelectorArgs[0])\n    ? createSelectorArgs[0]\n    : createSelectorArgs\n\n  assertIsArrayOfFunctions<Selector>(\n    dependencies,\n    `createSelector expects all input-selectors to be functions, but received the following types: `\n  )\n\n  return dependencies as SelectorArray\n}\n\n/**\n * Runs each input selector and returns their collective results as an array.\n *\n * @param dependencies - An array of \"dependencies\" or \"input selectors\".\n * @param inputSelectorArgs - An array of arguments being passed to the input selectors.\n * @returns An array of input selector results.\n */\nexport function collectInputSelectorResults(\n  dependencies: SelectorArray,\n  inputSelectorArgs: unknown[] | IArguments\n) {\n  const inputSelectorResults = []\n  const { length } = dependencies\n  for (let i = 0; i < length; i++) {\n    // @ts-ignore\n    // apply arguments instead of spreading and mutate a local list of params for performance.\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs))\n  }\n  return inputSelectorResults\n}\n\n/**\n * Retrieves execution information for development mode checks.\n *\n * @param devModeChecks - Custom Settings for development mode checks. These settings will override the global defaults.\n * @param firstRun - Indicates whether it is the first time the selector has run.\n * @returns  An object containing the execution information for each development mode check.\n */\nexport const getDevModeChecksExecutionInfo = (\n  firstRun: boolean,\n  devModeChecks: Partial<DevModeChecks>\n) => {\n  const { identityFunctionCheck, inputStabilityCheck } = {\n    ...globalDevModeChecks,\n    ...devModeChecks\n  }\n  return {\n    identityFunctionCheck: {\n      shouldRun:\n        identityFunctionCheck === 'always' ||\n        (identityFunctionCheck === 'once' && firstRun),\n      run: runIdentityFunctionCheck\n    },\n    inputStabilityCheck: {\n      shouldRun:\n        inputStabilityCheck === 'always' ||\n        (inputStabilityCheck === 'once' && firstRun),\n      run: runInputStabilityCheck\n    }\n  } satisfies DevModeChecksExecutionInfo\n}\n","// Original source:\n// - https://github.com/simonihmig/tracked-redux/blob/master/packages/tracked-redux/src/-private/proxy.ts\n\nimport type { Node, Tag } from './tracking'\nimport {\n  consumeCollection,\n  consumeTag,\n  createTag,\n  dirtyCollection,\n  dirtyTag\n} from './tracking'\n\nexport const REDUX_PROXY_LABEL = Symbol()\n\nlet nextId = 0\n\nconst proto = Object.getPrototypeOf({})\n\nclass ObjectTreeNode<T extends Record<string, unknown>> implements Node<T> {\n  proxy: T = new Proxy(this, objectProxyHandler) as unknown as T\n  tag = createTag()\n  tags = {} as Record<string, Tag>\n  children = {} as Record<string, Node>\n  collectionTag = null\n  id = nextId++\n\n  constructor(public value: T) {\n    this.value = value\n    this.tag.value = value\n  }\n}\n\nconst objectProxyHandler = {\n  get(node: Node, key: string | symbol): unknown {\n    function calculateResult() {\n      const { value } = node\n\n      const childValue = Reflect.get(value, key)\n\n      if (typeof key === 'symbol') {\n        return childValue\n      }\n\n      if (key in proto) {\n        return childValue\n      }\n\n      if (typeof childValue === 'object' && childValue !== null) {\n        let childNode = node.children[key]\n\n        if (childNode === undefined) {\n          childNode = node.children[key] = createNode(childValue)\n        }\n\n        if (childNode.tag) {\n          consumeTag(childNode.tag)\n        }\n\n        return childNode.proxy\n      } else {\n        let tag = node.tags[key]\n\n        if (tag === undefined) {\n          tag = node.tags[key] = createTag()\n          tag.value = childValue\n        }\n\n        consumeTag(tag)\n\n        return childValue\n      }\n    }\n    const res = calculateResult()\n    return res\n  },\n\n  ownKeys(node: Node): ArrayLike<string | symbol> {\n    consumeCollection(node)\n    return Reflect.ownKeys(node.value)\n  },\n\n  getOwnPropertyDescriptor(\n    node: Node,\n    prop: string | symbol\n  ): PropertyDescriptor | undefined {\n    return Reflect.getOwnPropertyDescriptor(node.value, prop)\n  },\n\n  has(node: Node, prop: string | symbol): boolean {\n    return Reflect.has(node.value, prop)\n  }\n}\n\nclass ArrayTreeNode<T extends Array<unknown>> implements Node<T> {\n  proxy: T = new Proxy([this], arrayProxyHandler) as unknown as T\n  tag = createTag()\n  tags = {}\n  children = {}\n  collectionTag = null\n  id = nextId++\n\n  constructor(public value: T) {\n    this.value = value\n    this.tag.value = value\n  }\n}\n\nconst arrayProxyHandler = {\n  get([node]: [Node], key: string | symbol): unknown {\n    if (key === 'length') {\n      consumeCollection(node)\n    }\n\n    return objectProxyHandler.get(node, key)\n  },\n\n  ownKeys([node]: [Node]): ArrayLike<string | symbol> {\n    return objectProxyHandler.ownKeys(node)\n  },\n\n  getOwnPropertyDescriptor(\n    [node]: [Node],\n    prop: string | symbol\n  ): PropertyDescriptor | undefined {\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop)\n  },\n\n  has([node]: [Node], prop: string | symbol): boolean {\n    return objectProxyHandler.has(node, prop)\n  }\n}\n\nexport function createNode<T extends Array<unknown> | Record<string, unknown>>(\n  value: T\n): Node<T> {\n  if (Array.isArray(value)) {\n    return new ArrayTreeNode(value)\n  }\n\n  return new ObjectTreeNode(value) as Node<T>\n}\n\nconst keysMap = new WeakMap<\n  Array<unknown> | Record<string, unknown>,\n  Set<string>\n>()\n\nexport function updateNode<T extends Array<unknown> | Record<string, unknown>>(\n  node: Node<T>,\n  newValue: T\n): void {\n  const { value, tags, children } = node\n\n  node.value = newValue\n\n  if (\n    Array.isArray(value) &&\n    Array.isArray(newValue) &&\n    value.length !== newValue.length\n  ) {\n    dirtyCollection(node)\n  } else {\n    if (value !== newValue) {\n      let oldKeysSize = 0\n      let newKeysSize = 0\n      let anyKeysAdded = false\n\n      for (const _key in value) {\n        oldKeysSize++\n      }\n\n      for (const key in newValue) {\n        newKeysSize++\n        if (!(key in value)) {\n          anyKeysAdded = true\n          break\n        }\n      }\n\n      const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize\n\n      if (isDifferent) {\n        dirtyCollection(node)\n      }\n    }\n  }\n\n  for (const key in tags) {\n    const childValue = (value as Record<string, unknown>)[key]\n    const newChildValue = (newValue as Record<string, unknown>)[key]\n\n    if (childValue !== newChildValue) {\n      dirtyCollection(node)\n      dirtyTag(tags[key], newChildValue)\n    }\n\n    if (typeof newChildValue === 'object' && newChildValue !== null) {\n      delete tags[key]\n    }\n  }\n\n  for (const key in children) {\n    const childNode = children[key]\n    const newChildValue = (newValue as Record<string, unknown>)[key]\n\n    const childValue = childNode.value\n\n    if (childValue === newChildValue) {\n      continue\n    } else if (typeof newChildValue === 'object' && newChildValue !== null) {\n      updateNode(childNode, newChildValue as Record<string, unknown>)\n    } else {\n      deleteNode(childNode)\n      delete children[key]\n    }\n  }\n}\n\nfunction deleteNode(node: Node): void {\n  if (node.tag) {\n    dirtyTag(node.tag, null)\n  }\n  dirtyCollection(node)\n  for (const key in node.tags) {\n    dirtyTag(node.tags[key], null)\n  }\n  for (const key in node.children) {\n    deleteNode(node.children[key])\n  }\n}\n","// Original source:\n// - https://github.com/facebook/react/blob/0b974418c9a56f6c560298560265dcf4b65784bc/packages/react/src/ReactCache.js\n\nimport type {\n  AnyFunction,\n  DefaultMemoizeFields,\n  EqualityFn,\n  Simplify\n} from './types'\n\nclass StrongRef<T> {\n  constructor(private value: T) {}\n  deref() {\n    return this.value\n  }\n}\n\nconst Ref =\n  typeof WeakRef !== 'undefined'\n    ? WeakRef\n    : (StrongRef as unknown as typeof WeakRef)\n\nconst UNTERMINATED = 0\nconst TERMINATED = 1\n\ninterface UnterminatedCacheNode<T> {\n  /**\n   * Status, represents whether the cached computation returned a value or threw an error.\n   */\n  s: 0\n  /**\n   * Value, either the cached result or an error, depending on status.\n   */\n  v: void\n  /**\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\n   */\n  o: null | WeakMap<Function | Object, CacheNode<T>>\n  /**\n   * Primitive cache, a regular Map where primitive arguments are stored.\n   */\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\n}\n\ninterface TerminatedCacheNode<T> {\n  /**\n   * Status, represents whether the cached computation returned a value or threw an error.\n   */\n  s: 1\n  /**\n   * Value, either the cached result or an error, depending on status.\n   */\n  v: T\n  /**\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\n   */\n  o: null | WeakMap<Function | Object, CacheNode<T>>\n  /**\n   * Primitive cache, a regular `Map` where primitive arguments are stored.\n   */\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\n}\n\ntype CacheNode<T> = TerminatedCacheNode<T> | UnterminatedCacheNode<T>\n\nfunction createCacheNode<T>(): CacheNode<T> {\n  return {\n    s: UNTERMINATED,\n    v: undefined,\n    o: null,\n    p: null\n  }\n}\n\n/**\n * Configuration options for a memoization function utilizing `WeakMap` for\n * its caching mechanism.\n *\n * @template Result - The type of the return value of the memoized function.\n *\n * @since 5.0.0\n * @public\n */\nexport interface WeakMapMemoizeOptions<Result = any> {\n  /**\n   * If provided, used to compare a newly generated output value against previous values in the cache.\n   * If a match is found, the old value is returned. This addresses the common\n   * ```ts\n   * todos.map(todo => todo.id)\n   * ```\n   * use case, where an update to another field in the original data causes a recalculation\n   * due to changed references, but the output is still effectively the same.\n   *\n   * @since 5.0.0\n   */\n  resultEqualityCheck?: EqualityFn<Result>\n}\n\n/**\n * Creates a tree of `WeakMap`-based cache nodes based on the identity of the\n * arguments it's been called with (in this case, the extracted values from your input selectors).\n * This allows `weakMapMemoize` to have an effectively infinite cache size.\n * Cache results will be kept in memory as long as references to the arguments still exist,\n * and then cleared out as the arguments are garbage-collected.\n *\n * __Design Tradeoffs for `weakMapMemoize`:__\n * - Pros:\n *   - It has an effectively infinite cache size, but you have no control over\n *   how long values are kept in cache as it's based on garbage collection and `WeakMap`s.\n * - Cons:\n *   - There's currently no way to alter the argument comparisons.\n *   They're based on strict reference equality.\n *   - It's roughly the same speed as `lruMemoize`, although likely a fraction slower.\n *\n * __Use Cases for `weakMapMemoize`:__\n * - This memoizer is likely best used for cases where you need to call the\n * same selector instance with many different arguments, such as a single\n * selector instance that is used in a list item component and called with\n * item IDs like:\n *   ```ts\n *   useSelector(state => selectSomeData(state, props.category))\n *   ```\n * @param func - The function to be memoized.\n * @returns A memoized function with a `.clearCache()` method attached.\n *\n * @example\n * <caption>Using `createSelector`</caption>\n * ```ts\n * import { createSelector, weakMapMemoize } from 'reselect'\n *\n * interface RootState {\n *   items: { id: number; category: string; name: string }[]\n * }\n *\n * const selectItemsByCategory = createSelector(\n *   [\n *     (state: RootState) => state.items,\n *     (state: RootState, category: string) => category\n *   ],\n *   (items, category) => items.filter(item => item.category === category),\n *   {\n *     memoize: weakMapMemoize,\n *     argsMemoize: weakMapMemoize\n *   }\n * )\n * ```\n *\n * @example\n * <caption>Using `createSelectorCreator`</caption>\n * ```ts\n * import { createSelectorCreator, weakMapMemoize } from 'reselect'\n *\n * const createSelectorWeakMap = createSelectorCreator({ memoize: weakMapMemoize, argsMemoize: weakMapMemoize })\n *\n * const selectItemsByCategory = createSelectorWeakMap(\n *   [\n *     (state: RootState) => state.items,\n *     (state: RootState, category: string) => category\n *   ],\n *   (items, category) => items.filter(item => item.category === category)\n * )\n * ```\n *\n * @template Func - The type of the function that is memoized.\n *\n * @see {@link https://reselect.js.org/api/weakMapMemoize `weakMapMemoize`}\n *\n * @since 5.0.0\n * @public\n * @experimental\n */\nexport function weakMapMemoize<Func extends AnyFunction>(\n  func: Func,\n  options: WeakMapMemoizeOptions<ReturnType<Func>> = {}\n) {\n  let fnNode = createCacheNode()\n  const { resultEqualityCheck } = options\n\n  let lastResult: WeakRef<object> | undefined\n\n  let resultsCount = 0\n\n  function memoized() {\n    let cacheNode = fnNode\n    const { length } = arguments\n    for (let i = 0, l = length; i < l; i++) {\n      const arg = arguments[i]\n      if (\n        typeof arg === 'function' ||\n        (typeof arg === 'object' && arg !== null)\n      ) {\n        // Objects go into a WeakMap\n        let objectCache = cacheNode.o\n        if (objectCache === null) {\n          cacheNode.o = objectCache = new WeakMap()\n        }\n        const objectNode = objectCache.get(arg)\n        if (objectNode === undefined) {\n          cacheNode = createCacheNode()\n          objectCache.set(arg, cacheNode)\n        } else {\n          cacheNode = objectNode\n        }\n      } else {\n        // Primitives go into a regular Map\n        let primitiveCache = cacheNode.p\n        if (primitiveCache === null) {\n          cacheNode.p = primitiveCache = new Map()\n        }\n        const primitiveNode = primitiveCache.get(arg)\n        if (primitiveNode === undefined) {\n          cacheNode = createCacheNode()\n          primitiveCache.set(arg, cacheNode)\n        } else {\n          cacheNode = primitiveNode\n        }\n      }\n    }\n\n    const terminatedNode = cacheNode as unknown as TerminatedCacheNode<any>\n\n    let result\n\n    if (cacheNode.s === TERMINATED) {\n      result = cacheNode.v\n    } else {\n      // Allow errors to propagate\n      result = func.apply(null, arguments as unknown as any[])\n      resultsCount++\n    }\n\n    terminatedNode.s = TERMINATED\n\n    if (resultEqualityCheck) {\n      const lastResultValue = lastResult?.deref?.() ?? lastResult\n      if (\n        lastResultValue != null &&\n        resultEqualityCheck(lastResultValue as ReturnType<Func>, result)\n      ) {\n        result = lastResultValue\n        resultsCount !== 0 && resultsCount--\n      }\n\n      const needsWeakRef =\n        (typeof result === 'object' && result !== null) ||\n        typeof result === 'function'\n      lastResult = needsWeakRef ? new Ref(result) : result\n    }\n    terminatedNode.v = result\n    return result\n  }\n\n  memoized.clearCache = () => {\n    fnNode = createCacheNode()\n    memoized.resetResultsCount()\n  }\n\n  memoized.resultsCount = () => resultsCount\n\n  memoized.resetResultsCount = () => {\n    resultsCount = 0\n  }\n\n  return memoized as Func & Simplify<DefaultMemoizeFields>\n}\n","import { weakMapMemoize } from './weakMapMemoize'\n\nimport type {\n  Combiner,\n  CreateSelectorOptions,\n  DropFirstParameter,\n  ExtractMemoizerFields,\n  GetParamsFromSelectors,\n  GetStateFromSelectors,\n  InterruptRecursion,\n  OutputSelector,\n  Selector,\n  SelectorArray,\n  SetRequired,\n  Simplify,\n  UnknownMemoizer\n} from './types'\n\nimport {\n  assertIsFunction,\n  collectInputSelectorResults,\n  ensureIsArray,\n  getDependencies,\n  getDevModeChecksExecutionInfo\n} from './utils'\n\n/**\n * An instance of `createSelector`, customized with a given memoize implementation.\n *\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\n * @template StateType - The type of state that the selectors created with this selector creator will operate on.\n *\n * @public\n */\nexport interface CreateSelectorFunction<\n  MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\n  StateType = any\n> {\n  /**\n   * Creates a memoized selector function.\n   *\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments and a `combiner` function.\n   * @returns A memoized output selector.\n   *\n   * @template InputSelectors - The type of the input selectors as an array.\n   * @template Result - The return type of the `combiner` as well as the output selector.\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\n   *\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\n   */\n  <InputSelectors extends SelectorArray<StateType>, Result>(\n    ...createSelectorArgs: [\n      ...inputSelectors: InputSelectors,\n      combiner: Combiner<InputSelectors, Result>\n    ]\n  ): OutputSelector<\n    InputSelectors,\n    Result,\n    MemoizeFunction,\n    ArgsMemoizeFunction\n  > &\n    InterruptRecursion\n\n  /**\n   * Creates a memoized selector function.\n   *\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments, a `combiner` function and an `options` object.\n   * @returns A memoized output selector.\n   *\n   * @template InputSelectors - The type of the input selectors as an array.\n   * @template Result - The return type of the `combiner` as well as the output selector.\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\n   *\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\n   */\n  <\n    InputSelectors extends SelectorArray<StateType>,\n    Result,\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\n  >(\n    ...createSelectorArgs: [\n      ...inputSelectors: InputSelectors,\n      combiner: Combiner<InputSelectors, Result>,\n      createSelectorOptions: Simplify<\n        CreateSelectorOptions<\n          MemoizeFunction,\n          ArgsMemoizeFunction,\n          OverrideMemoizeFunction,\n          OverrideArgsMemoizeFunction\n        >\n      >\n    ]\n  ): OutputSelector<\n    InputSelectors,\n    Result,\n    OverrideMemoizeFunction,\n    OverrideArgsMemoizeFunction\n  > &\n    InterruptRecursion\n\n  /**\n   * Creates a memoized selector function.\n   *\n   * @param inputSelectors - An array of input selectors.\n   * @param combiner - A function that Combines the input selectors and returns an output selector. Otherwise known as the result function.\n   * @param createSelectorOptions - An optional options object that allows for further customization per selector.\n   * @returns A memoized output selector.\n   *\n   * @template InputSelectors - The type of the input selectors array.\n   * @template Result - The return type of the `combiner` as well as the output selector.\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\n   *\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\n   */\n  <\n    InputSelectors extends SelectorArray<StateType>,\n    Result,\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\n  >(\n    inputSelectors: [...InputSelectors],\n    combiner: Combiner<InputSelectors, Result>,\n    createSelectorOptions?: Simplify<\n      CreateSelectorOptions<\n        MemoizeFunction,\n        ArgsMemoizeFunction,\n        OverrideMemoizeFunction,\n        OverrideArgsMemoizeFunction\n      >\n    >\n  ): OutputSelector<\n    InputSelectors,\n    Result,\n    OverrideMemoizeFunction,\n    OverrideArgsMemoizeFunction\n  > &\n    InterruptRecursion\n\n  /**\n   * Creates a \"pre-typed\" version of {@linkcode createSelector createSelector}\n   * where the `state` type is predefined.\n   *\n   * This allows you to set the `state` type once, eliminating the need to\n   * specify it with every {@linkcode createSelector createSelector} call.\n   *\n   * @returns A pre-typed `createSelector` with the state type already defined.\n   *\n   * @example\n   * ```ts\n   * import { createSelector } from 'reselect'\n   *\n   * export interface RootState {\n   *   todos: { id: number; completed: boolean }[]\n   *   alerts: { id: number; read: boolean }[]\n   * }\n   *\n   * export const createAppSelector = createSelector.withTypes<RootState>()\n   *\n   * const selectTodoIds = createAppSelector(\n   *   [\n   *     // Type of `state` is set to `RootState`, no need to manually set the type\n   *     state => state.todos\n   *   ],\n   *   todos => todos.map(({ id }) => id)\n   * )\n   * ```\n   * @template OverrideStateType - The specific type of state used by all selectors created with this selector creator.\n   *\n   * @see {@link https://reselect.js.org/api/createselector#defining-a-pre-typed-createselector `createSelector.withTypes`}\n   *\n   * @since 5.1.0\n   */\n  withTypes: <OverrideStateType extends StateType>() => CreateSelectorFunction<\n    MemoizeFunction,\n    ArgsMemoizeFunction,\n    OverrideStateType\n  >\n}\n\n/**\n * Creates a selector creator function with the specified memoization function\n * and options for customizing memoization behavior.\n *\n * @param options - An options object containing the `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). It also provides additional options for customizing memoization. While the `memoize` property is mandatory, the rest are optional.\n * @returns A customized `createSelector` function.\n *\n * @example\n * ```ts\n * const customCreateSelector = createSelectorCreator({\n *   memoize: customMemoize, // Function to be used to memoize `resultFunc`\n *   memoizeOptions: [memoizeOption1, memoizeOption2], // Options passed to `customMemoize` as the second argument onwards\n *   argsMemoize: customArgsMemoize, // Function to be used to memoize the selector's arguments\n *   argsMemoizeOptions: [argsMemoizeOption1, argsMemoizeOption2] // Options passed to `customArgsMemoize` as the second argument onwards\n * })\n *\n * const customSelector = customCreateSelector(\n *   [inputSelector1, inputSelector2],\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\n * )\n *\n * customSelector(\n *   ...selectorArgs // Will be memoized by `customArgsMemoize`\n * )\n * ```\n *\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\n *\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-options-since-500 `createSelectorCreator`}\n *\n * @since 5.0.0\n * @public\n */\nexport function createSelectorCreator<\n  MemoizeFunction extends UnknownMemoizer,\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\n>(\n  options: Simplify<\n    SetRequired<\n      CreateSelectorOptions<\n        typeof weakMapMemoize,\n        typeof weakMapMemoize,\n        MemoizeFunction,\n        ArgsMemoizeFunction\n      >,\n      'memoize'\n    >\n  >\n): CreateSelectorFunction<MemoizeFunction, ArgsMemoizeFunction>\n\n/**\n * Creates a selector creator function with the specified memoization function\n * and options for customizing memoization behavior.\n *\n * @param memoize - The `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\n * @returns A customized `createSelector` function.\n *\n * @example\n * ```ts\n * const customCreateSelector = createSelectorCreator(customMemoize, // Function to be used to memoize `resultFunc`\n *   option1, // Will be passed as second argument to `customMemoize`\n *   option2, // Will be passed as third argument to `customMemoize`\n *   option3 // Will be passed as fourth argument to `customMemoize`\n * )\n *\n * const customSelector = customCreateSelector(\n *   [inputSelector1, inputSelector2],\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\n * )\n * ```\n *\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\n *\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-memoize-and-memoizeoptions `createSelectorCreator`}\n *\n * @public\n */\nexport function createSelectorCreator<MemoizeFunction extends UnknownMemoizer>(\n  memoize: MemoizeFunction,\n  ...memoizeOptionsFromArgs: DropFirstParameter<MemoizeFunction>\n): CreateSelectorFunction<MemoizeFunction>\n\n/**\n * Creates a selector creator function with the specified memoization\n * function and options for customizing memoization behavior.\n *\n * @param memoizeOrOptions - Either A `memoize` function or an `options` object containing the `memoize` function.\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\n * @returns A customized `createSelector` function.\n *\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\n * @template MemoizeOrOptions - The type of the first argument. It can either be a `memoize` function or an `options` object containing the `memoize` function.\n */\nexport function createSelectorCreator<\n  MemoizeFunction extends UnknownMemoizer,\n  ArgsMemoizeFunction extends UnknownMemoizer,\n  MemoizeOrOptions extends\n    | MemoizeFunction\n    | SetRequired<\n        CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\n        'memoize'\n      >\n>(\n  memoizeOrOptions: MemoizeOrOptions,\n  ...memoizeOptionsFromArgs: MemoizeOrOptions extends SetRequired<\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\n    'memoize'\n  >\n    ? never\n    : DropFirstParameter<MemoizeFunction>\n) {\n  /** options initially passed into `createSelectorCreator`. */\n  const createSelectorCreatorOptions: SetRequired<\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\n    'memoize'\n  > = typeof memoizeOrOptions === 'function'\n    ? {\n        memoize: memoizeOrOptions as MemoizeFunction,\n        memoizeOptions: memoizeOptionsFromArgs\n      }\n    : memoizeOrOptions\n\n  const createSelector = <\n    InputSelectors extends SelectorArray,\n    Result,\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\n  >(\n    ...createSelectorArgs: [\n      ...inputSelectors: [...InputSelectors],\n      combiner: Combiner<InputSelectors, Result>,\n      createSelectorOptions?: CreateSelectorOptions<\n        MemoizeFunction,\n        ArgsMemoizeFunction,\n        OverrideMemoizeFunction,\n        OverrideArgsMemoizeFunction\n      >\n    ]\n  ) => {\n    let recomputations = 0\n    let dependencyRecomputations = 0\n    let lastResult: Result\n\n    // Due to the intricacies of rest params, we can't do an optional arg after `...createSelectorArgs`.\n    // So, start by declaring the default value here.\n    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\n    let directlyPassedOptions: CreateSelectorOptions<\n      MemoizeFunction,\n      ArgsMemoizeFunction,\n      OverrideMemoizeFunction,\n      OverrideArgsMemoizeFunction\n    > = {}\n\n    // Normally, the result func or \"combiner\" is the last arg\n    let resultFunc = createSelectorArgs.pop() as\n      | Combiner<InputSelectors, Result>\n      | CreateSelectorOptions<\n          MemoizeFunction,\n          ArgsMemoizeFunction,\n          OverrideMemoizeFunction,\n          OverrideArgsMemoizeFunction\n        >\n\n    // If the result func is actually an _object_, assume it's our options object\n    if (typeof resultFunc === 'object') {\n      directlyPassedOptions = resultFunc\n      // and pop the real result func off\n      resultFunc = createSelectorArgs.pop() as Combiner<InputSelectors, Result>\n    }\n\n    assertIsFunction(\n      resultFunc,\n      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\n    )\n\n    // Determine which set of options we're using. Prefer options passed directly,\n    // but fall back to options given to `createSelectorCreator`.\n    const combinedOptions = {\n      ...createSelectorCreatorOptions,\n      ...directlyPassedOptions\n    }\n\n    const {\n      memoize,\n      memoizeOptions = [],\n      argsMemoize = weakMapMemoize,\n      argsMemoizeOptions = [],\n      devModeChecks = {}\n    } = combinedOptions\n\n    // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\n    // is an array. In most libs I've looked at, it's an equality function or options object.\n    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\n    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\n    // we wrap it in an array so we can apply it.\n    const finalMemoizeOptions = ensureIsArray(memoizeOptions)\n    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions)\n    const dependencies = getDependencies(createSelectorArgs) as InputSelectors\n\n    const memoizedResultFunc = memoize(function recomputationWrapper() {\n      recomputations++\n      // apply arguments instead of spreading for performance.\n      // @ts-ignore\n      return (resultFunc as Combiner<InputSelectors, Result>).apply(\n        null,\n        arguments\n      )\n    }, ...finalMemoizeOptions) as Combiner<InputSelectors, Result> &\n      ExtractMemoizerFields<OverrideMemoizeFunction>\n\n    let firstRun = true\n\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\n    const selector = argsMemoize(function dependenciesChecker() {\n      dependencyRecomputations++\n      /** Return values of input selectors which the `resultFunc` takes as arguments. */\n      const inputSelectorResults = collectInputSelectorResults(\n        dependencies,\n        arguments\n      )\n\n      // apply arguments instead of spreading for performance.\n      // @ts-ignore\n      lastResult = memoizedResultFunc.apply(null, inputSelectorResults)\n\n      if (process.env.NODE_ENV !== 'production') {\n        const { identityFunctionCheck, inputStabilityCheck } =\n          getDevModeChecksExecutionInfo(firstRun, devModeChecks)\n        if (identityFunctionCheck.shouldRun) {\n          identityFunctionCheck.run(\n            resultFunc as Combiner<InputSelectors, Result>,\n            inputSelectorResults,\n            lastResult\n          )\n        }\n\n        if (inputStabilityCheck.shouldRun) {\n          // make a second copy of the params, to check if we got the same results\n          const inputSelectorResultsCopy = collectInputSelectorResults(\n            dependencies,\n            arguments\n          )\n\n          inputStabilityCheck.run(\n            { inputSelectorResults, inputSelectorResultsCopy },\n            { memoize, memoizeOptions: finalMemoizeOptions },\n            arguments\n          )\n        }\n\n        if (firstRun) firstRun = false\n      }\n\n      return lastResult\n    }, ...finalArgsMemoizeOptions) as unknown as Selector<\n      GetStateFromSelectors<InputSelectors>,\n      Result,\n      GetParamsFromSelectors<InputSelectors>\n    > &\n      ExtractMemoizerFields<OverrideArgsMemoizeFunction>\n\n    return Object.assign(selector, {\n      resultFunc,\n      memoizedResultFunc,\n      dependencies,\n      dependencyRecomputations: () => dependencyRecomputations,\n      resetDependencyRecomputations: () => {\n        dependencyRecomputations = 0\n      },\n      lastResult: () => lastResult,\n      recomputations: () => recomputations,\n      resetRecomputations: () => {\n        recomputations = 0\n      },\n      memoize,\n      argsMemoize\n    }) as OutputSelector<\n      InputSelectors,\n      Result,\n      OverrideMemoizeFunction,\n      OverrideArgsMemoizeFunction\n    >\n  }\n\n  Object.assign(createSelector, {\n    withTypes: () => createSelector\n  })\n\n  return createSelector as CreateSelectorFunction<\n    MemoizeFunction,\n    ArgsMemoizeFunction\n  >\n}\n\n/**\n * Accepts one or more \"input selectors\" (either as separate arguments or a single array),\n * a single \"result function\" / \"combiner\", and an optional options object, and\n * generates a memoized selector function.\n *\n * @see {@link https://reselect.js.org/api/createSelector `createSelector`}\n *\n * @public\n */\nexport const createSelector =\n  /* #__PURE__ */ createSelectorCreator(weakMapMemoize)\n","import { createSelector } from './createSelectorCreator'\n\nimport type { CreateSelectorFunction } from './createSelectorCreator'\nimport type {\n  InterruptRecursion,\n  ObjectValuesToTuple,\n  OutputSelector,\n  Selector,\n  Simplify,\n  UnknownMemoizer\n} from './types'\nimport { assertIsObject } from './utils'\nimport type { weakMapMemoize } from './weakMapMemoize'\n\n/**\n * Represents a mapping of selectors to their return types.\n *\n * @template TObject - An object type where each property is a selector function.\n *\n * @public\n */\nexport type SelectorResultsMap<TObject extends SelectorsObject> = {\n  [Key in keyof TObject]: ReturnType<TObject[Key]>\n}\n\n/**\n * Represents a mapping of selectors for each key in a given root state.\n *\n * This type is a utility that takes a root state object type and\n * generates a corresponding set of selectors. Each selector is associated\n * with a key in the root state, allowing for the selection\n * of specific parts of the state.\n *\n * @template RootState - The type of the root state object.\n *\n * @since 5.0.0\n * @public\n */\nexport type RootStateSelectors<RootState = any> = {\n  [Key in keyof RootState]: Selector<RootState, RootState[Key], []>\n}\n\n/**\n * @deprecated Please use {@linkcode StructuredSelectorCreator.withTypes createStructuredSelector.withTypes<RootState>()} instead. This type will be removed in the future.\n * @template RootState - The type of the root state object.\n *\n * @since 5.0.0\n * @public\n */\nexport type TypedStructuredSelectorCreator<RootState = any> =\n  /**\n   * A convenience function that simplifies returning an object\n   * made up of selector results.\n   *\n   * @param inputSelectorsObject - A key value pair consisting of input selectors.\n   * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\n   * @returns A memoized structured selector.\n   *\n   * @example\n   * <caption>Modern Use Case</caption>\n   * ```ts\n   * import { createSelector, createStructuredSelector } from 'reselect'\n   *\n   * interface RootState {\n   *   todos: {\n   *     id: number\n   *     completed: boolean\n   *     title: string\n   *     description: string\n   *   }[]\n   *   alerts: { id: number; read: boolean }[]\n   * }\n   *\n   * // This:\n   * const structuredSelector = createStructuredSelector(\n   *   {\n   *     todos: (state: RootState) => state.todos,\n   *     alerts: (state: RootState) => state.alerts,\n   *     todoById: (state: RootState, id: number) => state.todos[id]\n   *   },\n   *   createSelector\n   * )\n   *\n   * // Is essentially the same as this:\n   * const selector = createSelector(\n   *   [\n   *     (state: RootState) => state.todos,\n   *     (state: RootState) => state.alerts,\n   *     (state: RootState, id: number) => state.todos[id]\n   *   ],\n   *   (todos, alerts, todoById) => {\n   *     return {\n   *       todos,\n   *       alerts,\n   *       todoById\n   *     }\n   *   }\n   * )\n   * ```\n   *\n   * @example\n   * <caption>In your component:</caption>\n   * ```tsx\n   * import type { RootState } from 'createStructuredSelector/modernUseCase'\n   * import { structuredSelector } from 'createStructuredSelector/modernUseCase'\n   * import type { FC } from 'react'\n   * import { useSelector } from 'react-redux'\n   *\n   * interface Props {\n   *   id: number\n   * }\n   *\n   * const MyComponent: FC<Props> = ({ id }) => {\n   *   const { todos, alerts, todoById } = useSelector((state: RootState) =>\n   *     structuredSelector(state, id)\n   *   )\n   *\n   *   return (\n   *     <div>\n   *       Next to do is:\n   *       <h2>{todoById.title}</h2>\n   *       <p>Description: {todoById.description}</p>\n   *       <ul>\n   *         <h3>All other to dos:</h3>\n   *         {todos.map(todo => (\n   *           <li key={todo.id}>{todo.title}</li>\n   *         ))}\n   *       </ul>\n   *     </div>\n   *   )\n   * }\n   * ```\n   *\n   * @example\n   * <caption>Simple Use Case</caption>\n   * ```ts\n   * const selectA = state => state.a\n   * const selectB = state => state.b\n   *\n   * // The result function in the following selector\n   * // is simply building an object from the input selectors\n   * const structuredSelector = createSelector(selectA, selectB, (a, b) => ({\n   *   a,\n   *   b\n   * }))\n   *\n   * const result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\n   * ```\n   *\n   * @template InputSelectorsObject - The shape of the input selectors object.\n   * @template MemoizeFunction - The type of the memoize function that is used to create the structured selector. It defaults to `weakMapMemoize`.\n   * @template ArgsMemoizeFunction - The type of the of the memoize function that is used to memoize the arguments passed into the generated structured selector. It defaults to `weakMapMemoize`.\n   *\n   * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\n   */\n  <\n    InputSelectorsObject extends RootStateSelectors<RootState> = RootStateSelectors<RootState>,\n    MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\n    ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\n  >(\n    inputSelectorsObject: InputSelectorsObject,\n    selectorCreator?: CreateSelectorFunction<\n      MemoizeFunction,\n      ArgsMemoizeFunction\n    >\n  ) => OutputSelector<\n    ObjectValuesToTuple<InputSelectorsObject>,\n    Simplify<SelectorResultsMap<InputSelectorsObject>>,\n    MemoizeFunction,\n    ArgsMemoizeFunction\n  > &\n    InterruptRecursion\n\n/**\n * Represents an object where each property is a selector function.\n *\n * @template StateType - The type of state that all the selectors operate on.\n *\n * @public\n */\nexport type SelectorsObject<StateType = any> = Record<\n  string,\n  Selector<StateType>\n>\n\n/**\n * It provides a way to create structured selectors.\n * The structured selector can take multiple input selectors\n * and map their output to an object with specific keys.\n *\n * @template StateType - The type of state that the structured selectors created with this structured selector creator will operate on.\n *\n * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\n *\n * @public\n */\nexport interface StructuredSelectorCreator<StateType = any> {\n  /**\n   * A convenience function that simplifies returning an object\n   * made up of selector results.\n   *\n   * @param inputSelectorsObject - A key value pair consisting of input selectors.\n   * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\n   * @returns A memoized structured selector.\n   *\n   * @example\n   * <caption>Modern Use Case</caption>\n   * ```ts\n   * import { createSelector, createStructuredSelector } from 'reselect'\n   *\n   * interface RootState {\n   *   todos: {\n   *     id: number\n   *     completed: boolean\n   *     title: string\n   *     description: string\n   *   }[]\n   *   alerts: { id: number; read: boolean }[]\n   * }\n   *\n   * // This:\n   * const structuredSelector = createStructuredSelector(\n   *   {\n   *     todos: (state: RootState) => state.todos,\n   *     alerts: (state: RootState) => state.alerts,\n   *     todoById: (state: RootState, id: number) => state.todos[id]\n   *   },\n   *   createSelector\n   * )\n   *\n   * // Is essentially the same as this:\n   * const selector = createSelector(\n   *   [\n   *     (state: RootState) => state.todos,\n   *     (state: RootState) => state.alerts,\n   *     (state: RootState, id: number) => state.todos[id]\n   *   ],\n   *   (todos, alerts, todoById) => {\n   *     return {\n   *       todos,\n   *       alerts,\n   *       todoById\n   *     }\n   *   }\n   * )\n   * ```\n   *\n   * @example\n   * <caption>In your component:</caption>\n   * ```tsx\n   * import type { RootState } from 'createStructuredSelector/modernUseCase'\n   * import { structuredSelector } from 'createStructuredSelector/modernUseCase'\n   * import type { FC } from 'react'\n   * import { useSelector } from 'react-redux'\n   *\n   * interface Props {\n   *   id: number\n   * }\n   *\n   * const MyComponent: FC<Props> = ({ id }) => {\n   *   const { todos, alerts, todoById } = useSelector((state: RootState) =>\n   *     structuredSelector(state, id)\n   *   )\n   *\n   *   return (\n   *     <div>\n   *       Next to do is:\n   *       <h2>{todoById.title}</h2>\n   *       <p>Description: {todoById.description}</p>\n   *       <ul>\n   *         <h3>All other to dos:</h3>\n   *         {todos.map(todo => (\n   *           <li key={todo.id}>{todo.title}</li>\n   *         ))}\n   *       </ul>\n   *     </div>\n   *   )\n   * }\n   * ```\n   *\n   * @example\n   * <caption>Simple Use Case</caption>\n   * ```ts\n   * const selectA = state => state.a\n   * const selectB = state => state.b\n   *\n   * // The result function in the following selector\n   * // is simply building an object from the input selectors\n   * const structuredSelector = createSelector(selectA, selectB, (a, b) => ({\n   *   a,\n   *   b\n   * }))\n   *\n   * const result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\n   * ```\n   *\n   * @template InputSelectorsObject - The shape of the input selectors object.\n   * @template MemoizeFunction - The type of the memoize function that is used to create the structured selector. It defaults to `weakMapMemoize`.\n   * @template ArgsMemoizeFunction - The type of the of the memoize function that is used to memoize the arguments passed into the generated structured selector. It defaults to `weakMapMemoize`.\n   *\n   * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\n   */\n  <\n    InputSelectorsObject extends SelectorsObject<StateType>,\n    MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\n    ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\n  >(\n    inputSelectorsObject: InputSelectorsObject,\n    selectorCreator?: CreateSelectorFunction<\n      MemoizeFunction,\n      ArgsMemoizeFunction\n    >\n  ): OutputSelector<\n    ObjectValuesToTuple<InputSelectorsObject>,\n    Simplify<SelectorResultsMap<InputSelectorsObject>>,\n    MemoizeFunction,\n    ArgsMemoizeFunction\n  > &\n    InterruptRecursion\n\n  /**\n   * Creates a \"pre-typed\" version of\n   * {@linkcode createStructuredSelector createStructuredSelector}\n   * where the `state` type is predefined.\n   *\n   * This allows you to set the `state` type once, eliminating the need to\n   * specify it with every\n   * {@linkcode createStructuredSelector createStructuredSelector} call.\n   *\n   * @returns A pre-typed `createStructuredSelector` with the state type already defined.\n   *\n   * @example\n   * ```ts\n   * import { createStructuredSelector } from 'reselect'\n   *\n   * export interface RootState {\n   *   todos: { id: number; completed: boolean }[]\n   *   alerts: { id: number; read: boolean }[]\n   * }\n   *\n   * export const createStructuredAppSelector =\n   *   createStructuredSelector.withTypes<RootState>()\n   *\n   * const structuredAppSelector = createStructuredAppSelector({\n   *   // Type of `state` is set to `RootState`, no need to manually set the type\n   *   todos: state => state.todos,\n   *   alerts: state => state.alerts,\n   *   todoById: (state, id: number) => state.todos[id]\n   * })\n   *\n   * ```\n   * @template OverrideStateType - The specific type of state used by all structured selectors created with this structured selector creator.\n   *\n   * @see {@link https://reselect.js.org/api/createstructuredselector#defining-a-pre-typed-createstructuredselector `createSelector.withTypes`}\n   *\n   * @since 5.1.0\n   */\n  withTypes: <\n    OverrideStateType extends StateType\n  >() => StructuredSelectorCreator<OverrideStateType>\n}\n\n/**\n * A convenience function that simplifies returning an object\n * made up of selector results.\n *\n * @param inputSelectorsObject - A key value pair consisting of input selectors.\n * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\n * @returns A memoized structured selector.\n *\n * @example\n * <caption>Modern Use Case</caption>\n * ```ts\n * import { createSelector, createStructuredSelector } from 'reselect'\n *\n * interface RootState {\n *   todos: {\n *     id: number\n *     completed: boolean\n *     title: string\n *     description: string\n *   }[]\n *   alerts: { id: number; read: boolean }[]\n * }\n *\n * // This:\n * const structuredSelector = createStructuredSelector(\n *   {\n *     todos: (state: RootState) => state.todos,\n *     alerts: (state: RootState) => state.alerts,\n *     todoById: (state: RootState, id: number) => state.todos[id]\n *   },\n *   createSelector\n * )\n *\n * // Is essentially the same as this:\n * const selector = createSelector(\n *   [\n *     (state: RootState) => state.todos,\n *     (state: RootState) => state.alerts,\n *     (state: RootState, id: number) => state.todos[id]\n *   ],\n *   (todos, alerts, todoById) => {\n *     return {\n *       todos,\n *       alerts,\n *       todoById\n *     }\n *   }\n * )\n * ```\n *\n * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\n *\n * @public\n */\nexport const createStructuredSelector: StructuredSelectorCreator =\n  Object.assign(\n    <\n      InputSelectorsObject extends SelectorsObject,\n      MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\n      ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\n    >(\n      inputSelectorsObject: InputSelectorsObject,\n      selectorCreator: CreateSelectorFunction<\n        MemoizeFunction,\n        ArgsMemoizeFunction\n      > = createSelector as CreateSelectorFunction<\n        MemoizeFunction,\n        ArgsMemoizeFunction\n      >\n    ) => {\n      assertIsObject(\n        inputSelectorsObject,\n        'createStructuredSelector expects first argument to be an object ' +\n          `where each property is a selector, instead received a ${typeof inputSelectorsObject}`\n      )\n      const inputSelectorKeys = Object.keys(inputSelectorsObject)\n      const dependencies = inputSelectorKeys.map(\n        key => inputSelectorsObject[key]\n      )\n      const structuredSelector = selectorCreator(\n        dependencies,\n        (...inputSelectorResults: any[]) => {\n          return inputSelectorResults.reduce((composition, value, index) => {\n            composition[inputSelectorKeys[index]] = value\n            return composition\n          }, {})\n        }\n      )\n      return structuredSelector\n    },\n    { withTypes: () => createStructuredSelector }\n  ) as StructuredSelectorCreator\n","import { createSelector } from 'reselect'\r\n\r\nexport let getNumberPage = (state) => {\r\n    return state.usersData.numberPage\r\n}\r\n\r\nexport let getCountPage = (state) => {\r\n    return state.usersData.countPage\r\n}\r\n\r\nexport let getUsers = (state) => {\r\n    return state.usersData.users.filter(u => true)\r\n}\r\n\r\nexport let getUsersReselect = createSelector(getUsers, (users) => {\r\n    return users.filter(u => true)\r\n})\r\n\r\nexport let getToggleFollowingProgress = (state) => {\r\n    return state.usersData.toggleFollowingProgress\r\n}\r\n\r\nexport let getNumberName = (state) => {\r\n    return state.usersData.numberName\r\n}","import React, { PureComponent } from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { setCount, setNumberPage, setUsers, getNumberThunk,deleteUsersThunk,postUsersThunk,followFriend} from \"../../redux/user-reducer\";\r\nimport { startLoader, stopLoader } from \"../../redux/finding-reducer\";\r\nimport Users from './Users';\r\nimport { toggleFollowing, getUsersThunk } from './../../redux/user-reducer';\r\nimport RedirectHoc from './../../hocs/RedirectHoc';\r\nimport { compose } from \"redux\";\r\nimport { getCountPage, getNumberName, getNumberPage, getToggleFollowingProgress, getUsersReselect } from \"../../redux/redux-select/user-reselect\";\r\nimport { getStatus } from \"../../redux/redux-select/auth-reselect\";\r\n\r\nclass UserAPI extends PureComponent {\r\n\r\n\r\n    componentDidMount() {\r\n        // UserApi.getBtn().then(data => {\r\n        //     this.props.setNumberPage(Math.ceil(data.totalCount / this.props.state.numberName))\r\n        // })\r\n  \r\n        // UserApi.getUsers(this.props.state.numberName,this.props.state.countPage).then(data => {\r\n        //     this.props.setUsers(data.items)\r\n        //     this.props.stopLoader()\r\n        // })\r\n        this.props.getNumber(this.props.numberName)\r\n        this.props.getUsersThunk(this.props.numberName,this.props.countPage)\r\n    }\r\n\r\n    componentDidUpdate(f1,f2) {\r\n        if (f1.countPage !== this.props.countPage ) {\r\n            this.props.getUsersThunk(this.props.numberName,this.props.countPage)\r\n        }\r\n\r\n    }\r\n\r\n \r\n    onPageChange = (number) => {\r\n        this.props.setCount(number)\r\n        this.props.startLoader();\r\n    }\r\n\r\n\r\n    profileUpdateMetod = () => {\r\n        this.props.startLoader()\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div style={{position : \"relative\"}}>\r\n            <Users numberPage={this.props.numberPage}\r\n                countPage={this.props.countPage}\r\n                onPageChange={this.onPageChange}\r\n                users={this.props.users}\r\n                addFriend={this.props.findFriend}\r\n                deleteFriend={this.props.deleteFriend}\r\n                startLoader= {this.props.startLoader}\r\n                stopLoader= {this.props.stopLoader}\r\n                profileUpdateMetod = {this.profileUpdateMetod}\r\n                toggleFollowing = {this.props.toggleFollowing}\r\n                toggleFollowingProgress = {this.props.toggleFollowingProgress}\r\n                deleteUsersThunk = {this.props.deleteUsersThunk}\r\n                postUsersThunk = {this.props.postUsersThunk}\r\n                getUsersThunk = {this.props.getUsersThunk}\r\n                followFriend = {this.props.followFriend}\r\n            />\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nlet f1 = (state) => {\r\n    return {\r\n        statusLogin: getStatus(state),\r\n        numberPage: getNumberPage(state),\r\n        countPage : getCountPage(state),\r\n        users : getUsersReselect(state),\r\n        toggleFollowingProgress : getToggleFollowingProgress(state),\r\n        numberName: getNumberName(state)\r\n    }\r\n}\r\n\r\nlet f2 = {\r\n        setUsers,\r\n        setNumberPage,\r\n        setCount,\r\n        startLoader,\r\n        stopLoader,\r\n        toggleFollowing,\r\n        getNumber :getNumberThunk,\r\n        getUsersThunk,\r\n        deleteUsersThunk,\r\n        postUsersThunk,\r\n        followFriend\r\n}\r\n\r\n// const UsersContainer = connect(f1,f2)(RedirectHoc(UserAPI))\r\n\r\nconst UsersContainer = compose(\r\n    connect(f1,f2),\r\n    RedirectHoc\r\n)(\r\n    UserAPI\r\n)\r\n\r\nexport default UsersContainer","import React, { PureComponent } from 'react';\r\nimport { Navigate } from 'react-router-dom';\r\n\r\nconst RedirectHoc = (Component) => {\r\n    class NavigateHOC extends PureComponent  {\r\n        render() {\r\n            if(this.props.statusLogin === false) {\r\n                return <Navigate to={'/login/'}/>\r\n            } else {\r\n                return <Component {...this.props}/>\r\n            }\r\n        }\r\n    }\r\n\r\n    return NavigateHOC\r\n}\r\n\r\nexport default RedirectHoc"],"names":["React","props","pages","index","numberPage","push","_jsx","className","s","children","map","item","concat","countPage","onClick","e","onPageChange","_jsxs","user","NavLink","to","id","profileUpdate","startLoader","user__img","src","photos","small","large","alt","followed","disabled","toggleFollowingProgress","deleteFriend","user__btn","addFriend","user__list","name","status","Paginator","users","User","toggleFollowing","postUsersThunk","followFriend","deleteUsersThunk","profileUpdateMetod","assertIsFunction","func","errorMessage","arguments","length","undefined","TypeError","ensureIsArray","Array","isArray","getDependencies","createSelectorArgs","dependencies","array","every","itemTypes","join","assertIsArrayOfFunctions","Symbol","Object","getPrototypeOf","Ref","WeakRef","StrongRef","value","_classCallCheck","_createClass","key","this","UNTERMINATED","TERMINATED","createCacheNode","v","o","p","weakMapMemoize","lastResult","options","fnNode","resultEqualityCheck","resultsCount","memoized","cacheNode","i","l","arg","objectCache","WeakMap","objectNode","get","set","primitiveCache","Map","primitiveNode","result","terminatedNode","apply","_lastResult$deref","_lastResult","_lastResult$deref2","lastResultValue","deref","call","clearCache","resetResultsCount","createSelectorCreator","memoizeOrOptions","_len","memoizeOptionsFromArgs","_key5","createSelectorCreatorOptions","memoize","memoizeOptions","createSelector2","_len2","_key6","recomputations","dependencyRecomputations","directlyPassedOptions","resultFunc","pop","combinedOptions","_objectSpread","_combinedOptions$memo","_combinedOptions$args","argsMemoize","_combinedOptions$args2","argsMemoizeOptions","finalMemoizeOptions","devModeChecks","finalArgsMemoizeOptions","memoizedResultFunc","_toConsumableArray","selector","inputSelectorResults","inputSelectorArgs","collectInputSelectorResults","assign","resetDependencyRecomputations","resetRecomputations","withTypes","createSelector","createStructuredSelector","inputSelectorsObject","selectorCreator","object","assertIsObject","inputSelectorKeys","keys","structuredSelector","_len3","_key7","reduce","composition","getNumberPage","state","usersData","getCountPage","getUsersReselect","filter","u","getToggleFollowingProgress","getNumberName","numberName","UserAPI","_PureComponent","_inherits","_super","_createSuper","_this","args","_key","number","setCount","getNumber","getUsersThunk","f1","f2","style","position","Users","findFriend","stopLoader","PureComponent","setUsers","setNumberPage","getNumberThunk","compose","connect","statusLogin","getStatus","RedirectHoc","Component","NavigateHOC","Navigate"],"sourceRoot":""}